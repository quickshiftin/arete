#!/bin/bash
#-----------------------------------------------------------------
# A minimal BASH multi-host command executor,
# inspired by Fabric for Python.
#
# (c) Nathan Nobbe 2014
#-----------------------------------------------------------------

#------------------------------------------------------------
# scp wrapper for arete. This allows you to upload a file to
# an arbitrary set of remote machines.
#------------------------------------------------------------
function arete_put
{
    local local_file="$1"
    local remote_path="$2"

    # Loop over the commands running them on the target boxes
    for host in "${ARETE_HOSTS[@]}"; do
        if [ $ARETE_ASYNC -eq 1 ]; then
            ( scp "$local_file" "$host":"$remote_path") &
        else
            scp "$local_file" "$host":"$remote_path"
        fi
    done

    # Wait for the background jobs in async mode
    if [ $ARETE_ASYNC -eq 1 ]; then
        wait
    fi
}

#------------------------------------------------------------
# Run an arbitrary command on a number of remote machines.
# The command can be run synchronously or asynchronously.
#------------------------------------------------------------
function arete_run
{
    local command="$1"

    # Loop over the commands running them on the target boxes
    for host in "${ARETE_HOSTS[@]}"; do
        if [ $ARETE_ASYNC -eq 1 ]; then
            ( ssh -tt "$host"  "bash -c '$command'") &
        else
            ssh -tt "$host" "bash -c '$command'"
        fi
    done

    # Wait for the background jobs in async mode
    if [ $ARETE_ASYNC -eq 1 ]; then
        wait
    fi
}

#------------------------------------------------------------
# Append a single host to the list of hosts unless the host
# is already present in the list.
#------------------------------------------------------------
function arete_append_host
{
    # Create with initial element
    if [ -z "$ARETE_HOSTS" -o "${#ARETE_HOSTS[@]}" -eq 0 ]; then
        ARETE_HOSTS=("$1")

    # Append to the array
    else
        # Check the array to see if the host is already present
        case "${ARETE_HOSTS[@]}" in  *"$1"*) return 0 ;; esac

        ARETE_HOSTS+=("$1")
    fi
}

#------------------------------------------------------------
# Build a list of hosts to be used for remote execution. The
# arguments can be single hostnames or arrays, they will all
# be merged into a final list by arete_hosts.
#------------------------------------------------------------
function arete_hosts
{
    local a=
    local is_array=
    local arg=
    local inner_arg=

    # Loop over args
    for arg in $(seq $#); do
        # If argument is not an array, simply append it
        a="${!arg}"
        is_array=$(declare -p a 2> /dev/null | grep -q '^declare \-a' | wc -l)
        if [ "$is_array" -eq 1 ]; then
            for inner_arg in ${a[@]}; do
                arete_append_host $a["$inner_arg"]
            done
        else
            arete_append_host "$a"
        fi
    done
}

#------------------------------------------------------------
# Execute a single task given its name (which is the function
# name exclusive of the 'task_' prefix).
#------------------------------------------------------------
function arete
{
    local task="$1"
    if [ $(type -t "task${1}")"" == 'function' ]; then
        task="task_${1}"
    fi

    # For now arguments are any extra params, but at some point
    # let's take in args like fabric does :-delimited so hosts
    # can be specified on the fly
    "$task"
}

function _usage
{
    # If the invocation to arete was total garbage...
    if [ -z "$1" ]; then
        echo "$0" '[-s]' '<task>[:arg1,..argx]' '[host1 hostX]'
        return
    fi

    # If there's an 'arete file' to analyze, then do it
    egrep "function task_|^[^_].\+(){$" $1 | while read line; do
        # Tasks must be declared as function task_<task name>
        local cmd=$(echo "$line" | sed "s/(){//g" | sed 's/function task_//g')

        # Look for comments on top of the task, the last line of comments will
        # be used for the listing output
        local info=$(grep -C0 -A0 -B1 "function task_$cmd" $1 | sed "N;s/\n.*//g")

        # Print the name of the task and optionally a comment
        if [ -z "$info" ]; then
            printf "    %-20s\n" "$cmd"
        else
            printf "    %-20s %-40s\n" "$cmd" "$info" | grep "#"
        fi
    done; echo "";
}

# Process the arguments
ARETE_ASYNC=0
while getopts "ah" OPTION; do
    case "$OPTION" in
        a)
            ARETE_ASYNC=1
            ;;
        h)
            _usage
            exit 0
        #?)
        #    _usage
        #    exit 1
        #    ;;
    esac
done

# Bail if functions file is not a regular file
if [ ! -f "$1" ]; then
    if [ ! -z "$1" ]; then
        echo "$1" is not a regular file.
    else
        echo No task file nor command specified.
    fi
    _usage
    exit 1
fi

# Load the functions file and run the task
if [ $# -gt 1 ]; then
    source "$1"
    arete "$2"

# Show usage information
else
    _usage "$1"
    exit 1
fi
